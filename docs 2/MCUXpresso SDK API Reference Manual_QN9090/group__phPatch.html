<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Kinetis SDK v.2.0 API Reference Manual: Software Patch Module HAL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="fs_logo.gif"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">Kinetis SDK v.2.0 API Reference Manual
   &#160;<span id="projectnumber">Rev. 0</span>
   </div>
   <div id="projectbrief">NXP Semiconductors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__phPatch.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Software Patch Module HAL</div>  </div>
</div><!--header-->
<div class="contents">

<p>This module implements the JN518x patch mechanism.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Overview</h2>
<dl class="section user"><dt>Disambiguation</dt><dd>Since hardware and software is used for patch mechanism, two different modules are involved: <ul>
<li><b>Code Patch Module</b> - This is the hardware module providing support for code patch mechanism </li>
<li><b>Software Patch Module</b> - This refers to the software module which is described here.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Module functionalities</dt><dd>Since most of the PN547 code resides within ROM there has to be a way to apply patches for this code in case of a bug or feature change. There is support within hardware which provides such code patch functionality. The hardware block providing this is called Code Patch Module. Generally, it compares the address of a code fetch with a list of addresses stored within a set of hardware register which is depicted in the following figure.<br/>
<br/>
<div class="image">
<img src="PatchModule_LogicalViewHw.png" alt="PatchModule_LogicalViewHw.png"/>
</div>
 <br/>
<br/>
It shows the Code Patch Module located between ROM and the bus. The address of each code fetch from ROM is compared with the content of the patch address registers. In case of a match the Code Patch Module returns an SVC instruction (including the index of the address register as intermediate value) instead of the ROM data behind this address.<br/>
Since it is possible to change to content of the patch address registers during runtime the overall number of patches can be higher than the number of these registers. Basically, three different types of patches have been introduced from software point of view.<br/>
<br/>
<ul>
<li><b>Global patches:</b> Patches which have always to be activated since they are affecting a global functionality (e.g. patch for the RTOS). </li>
<li><b>Static patches:</b> Patches which have always to be activated during a defined system state. </li>
<li><b>Dynamic patches:</b> Patches which are applied before entering a function or module and removed when leaving it. <br/>
<br/>
It can be seen that global patches reduce the number of possible static and dynamic patches and generally spoken the number of overall patches. So there has to be a trade-off when partitioning the patch address registers.<br/>
<br/>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Patch Table</dt><dd>All possible patches are stored in a table which contains the address of the instruction to be patched, the patch entry and exit point address. User code is responsible for programming the patch address registers with the address from this patch table using API provided by the Software Patch Module. The patch table starts with the global patches and after the last global patch there has to be a dummy entry used as a marker. This dummy entry is defined by setting all 8 bytes to 0xff. (address to be patched 0xffff, patch entry point 0xffff, patch return address 0xffffffff)<br/>
<br/>
</dd></dl>
<dl class="section user"><dt>Patch Execution</dt><dd>As mentioned before, the Code Patch Module returns an SVC instruction which generates an exception when executed by the CPU. When SVC exception handler is entered only the index of the patch address register responsible for this exception is known. So the exception handler has to lookup within the patch table to get the patch entry point address. Since the index of the patch address register might not be the same as the offset of the patch table entry an additional lookup is needed. This is done using an memory array containing the offset for patch table entries of all activated patches.<br/>
<br/>
</dd></dl>
<dl class="section user"><dt>Lookup Array</dt><dd>This array has the same size as patches can be configured in Code Patch Module. The indices of the elements within the array correspond to the indices of the patch address registers. The first 7 bits (Bit 0-6) of the value behind each element of the array corresponds to the offset within the patch table. The MSB is used for enable/disable indication.<br/>
<br/>
<div class="image">
<img src="PatchModule_Lookup.png" alt="PatchModule_Lookup.png"/>
</div>
 <br/>
<br/>
The figure above shows the different involved memory entities. Specifically, it shows an example where address 0x170 needs to be patched. This address is programmed into the first patch address register (index 0). This index is used as offset for the patch lookup table (array) to retrieve the actual offset within the patch table. The highest possible offset, i.e. max. number of patches within the table is #PH_HAL_PATCH_INVALID_PATCH_TABLE_OFFSET - 1<br/>
</dd></dl>
<dl class="section user"><dt>Patch Life-Cycle</dt><dd>The following figure shows the life-cycle of a patch.<br/>
<br/>
<div class="image">
<img src="PatchModule_Lifecycle.png" alt="PatchModule_Lifecycle.png"/>
</div>
 <br/>
<br/>
When entering the SVC handler, the intermediate value of the SVC instruction (which corresponds to the index of the affected patch address register) is retrieved. This value is used as the index within the lookup array. The value got out of the array corresponds the index of the actual patch table entry. Using this index the entry point is fetched from the patch table, the exception handler is left and the actual patch is entered.</dd></dl>
<dl class="section user"><dt>Initialization</dt><dd>The following sequence diagram illustrates the initialization of the patch module.<br/>
<br/>
<div class="image">
<img src="PatchModule_InitSequence.png" alt="PatchModule_InitSequence.png"/>
</div>
 <br/>
<br/>
During <a class="el" href="">System Boot</a> Flash gets initialized and the integrity of the code section is checked. After that the initial lookup array is fetched from Flash and passed over as input parameter to <a class="el" href="group__phPatch.html#gaebe277a725c9d49517df2d4625b8147d" title="Patch Module Initialization. ">nxHal_Patch_Init</a>. This lookup array is copied to an internal array and the Code Patch Module is set up.</dd></dl>
<dl class="section user"><dt>Use cases</dt><dd>There are several use cases where a patch could be applied: <ul>
<li>Patch ROM code. This is the normal case where code in ROM is executed within task context. In case of bugs or feature changes this code needs to be patched. </li>
<li>Patch ISR code. Since interrupt service routines are also located in ROM it might also be possible that they have to be patched. </li>
<li>Interrupt during patch execution. Also patches shall be interruptible and after execution of the ISR the system returns to the patch. </li>
<li>Nested interrupt patch. A nested ISR (ISR which interrupts another ISR) can also be patched. </li>
<li>Patch within patch. A patch might execute ROM code which can then be patched again (Nested patches). </li>
<li>Combinations of use cases above. Also combinations (nested interrupt patch with nested code patch) is a possible use case. </li>
</ul>
</dd></dl>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:structnxHal__Patch__TableEntry__t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a></td></tr>
<tr class="memdesc:structnxHal__Patch__TableEntry__t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch Table Entry.  <a href="group__phPatch.html#structnxHal__Patch__TableEntry__t">More...</a><br/></td></tr>
<tr class="separator:structnxHal__Patch__TableEntry__t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga03b51e0a87daa85d7a6b938bbecdb569"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga03b51e0a87daa85d7a6b938bbecdb569">NX_HAL_PATCH_NUM_OF_PATCHES</a>&#160;&#160;&#160;48U</td></tr>
<tr class="separator:ga03b51e0a87daa85d7a6b938bbecdb569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab296ffe5183cb1c9225a24ee2edab335"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#gab296ffe5183cb1c9225a24ee2edab335">NX_HAL_PATCH_NULL_PTR</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gab296ffe5183cb1c9225a24ee2edab335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga711c0a572054534b682a0d7124eb8925"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga711c0a572054534b682a0d7124eb8925">pnxHal_SVC_Handler_t</a> )(void)</td></tr>
<tr class="separator:ga711c0a572054534b682a0d7124eb8925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56ba1e16ffafba194b594eb752678835"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a> )(void)</td></tr>
<tr class="separator:ga56ba1e16ffafba194b594eb752678835"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2ed3ea8e1f86480a3876241c6162a417"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga2ed3ea8e1f86480a3876241c6162a417">nxHal_Patch_DynamicPatchGroup_t</a> { <br/>
&#160;&#160;<a class="el" href="group__phPatch.html#gga2ed3ea8e1f86480a3876241c6162a417a1c5bcb4801752f95067edc84db48dd8e">E_PAGEFLASH_DYNAMIC_PATCH_ZIGBEE</a> = 0, 
<br/>
&#160;&#160;<a class="el" href="group__phPatch.html#gga2ed3ea8e1f86480a3876241c6162a417a25e6ed942179716d9279c9c4f9725d67">E_PAGEFLASH_DYNAMIC_PATCH_BLE</a>
<br/>
 }</td></tr>
<tr class="separator:ga2ed3ea8e1f86480a3876241c6162a417"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaebe277a725c9d49517df2d4625b8147d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#gaebe277a725c9d49517df2d4625b8147d">nxHal_Patch_Init</a> (const <a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a> *pPatchTable)</td></tr>
<tr class="memdesc:gaebe277a725c9d49517df2d4625b8147d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch Module Initialization.  <a href="#gaebe277a725c9d49517df2d4625b8147d">More...</a><br/></td></tr>
<tr class="separator:gaebe277a725c9d49517df2d4625b8147d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67ec032a6a497f3d885a7f592c2b0f22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga67ec032a6a497f3d885a7f592c2b0f22">nxHal_Patch_Apply</a> (uint8_t bPatchNumber, uint8_t bPatchTableOffset, uint8_t *pOldPatchTableOffset)</td></tr>
<tr class="memdesc:ga67ec032a6a497f3d885a7f592c2b0f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Patch.  <a href="#ga67ec032a6a497f3d885a7f592c2b0f22">More...</a><br/></td></tr>
<tr class="separator:ga67ec032a6a497f3d885a7f592c2b0f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77703a58c15e5a14f7158969d51ff8ba"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga77703a58c15e5a14f7158969d51ff8ba">nxHal_Patch_EnableDisable</a> (nxHal_Patch_bool_t blEnable, uint8_t bPatchNumber)</td></tr>
<tr class="memdesc:ga77703a58c15e5a14f7158969d51ff8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable or Enable a Patch.  <a href="#ga77703a58c15e5a14f7158969d51ff8ba">More...</a><br/></td></tr>
<tr class="separator:ga77703a58c15e5a14f7158969d51ff8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5676beb480f7f08664cd5041e2d99f2f"><td class="memItemLeft" align="right" valign="top">static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga5676beb480f7f08664cd5041e2d99f2f">nxHal_Patch_GetGlobalPatchMarkerIndex</a> (void)</td></tr>
<tr class="memdesc:ga5676beb480f7f08664cd5041e2d99f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return index of the global patch marker.  <a href="#ga5676beb480f7f08664cd5041e2d99f2f">More...</a><br/></td></tr>
<tr class="separator:ga5676beb480f7f08664cd5041e2d99f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bce87ce86d55e433218befc53770d52"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga8bce87ce86d55e433218befc53770d52">nxHal_Patch_ReadPatchEntry</a> (<a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a> *pBuffer, <a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a> *pFlash)</td></tr>
<tr class="separator:ga8bce87ce86d55e433218befc53770d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39fd6507a641ba3291ade6e82ec41664"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ga39fd6507a641ba3291ade6e82ec41664">nxHal_Patch_LoadDynamicPatches</a> (<a class="el" href="group__phPatch.html#ga2ed3ea8e1f86480a3876241c6162a417">nxHal_Patch_DynamicPatchGroup_t</a> ePatchGroup)</td></tr>
<tr class="separator:ga39fd6507a641ba3291ade6e82ec41664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Data Structure Documentation</h2>
<a name="structnxHal__Patch__TableEntry__t" id="structnxHal__Patch__TableEntry__t"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct nxHal_Patch_TableEntry_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>One patch table entry consists of the address to be patched, the entry point of the patch function and the return address. </p>
</div><table class="memberdecls">
<tr><td colspan="2"><h3>Data Fields</h3></td></tr>
<tr class="memitem:a0da7f68af3ee7f91a57ce8096b4b7826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#a0da7f68af3ee7f91a57ce8096b4b7826">wPatchOffsetAddress</a></td></tr>
<tr class="separator:a0da7f68af3ee7f91a57ce8096b4b7826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fbe55c87a4ac7e2f1e80e2afe3302a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#a77fbe55c87a4ac7e2f1e80e2afe3302a">wPatchEntryPoint</a></td></tr>
<tr class="separator:a77fbe55c87a4ac7e2f1e80e2afe3302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a71a82ba44fa39d1e4e8422bed3352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__phPatch.html#ad1a71a82ba44fa39d1e4e8422bed3352">wPatchReturnAddress</a></td></tr>
<tr class="separator:ad1a71a82ba44fa39d1e4e8422bed3352"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h4 class="groupheader">Field Documentation</h4>
<a class="anchor" id="a0da7f68af3ee7f91a57ce8096b4b7826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a> nxHal_Patch_TableEntry_t::wPatchOffsetAddress</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Patch address within ROM. </p>

</div>
</div>
<a class="anchor" id="a77fbe55c87a4ac7e2f1e80e2afe3302a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a> nxHal_Patch_TableEntry_t::wPatchEntryPoint</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flash patch entry point. </p>

</div>
</div>
<a class="anchor" id="ad1a71a82ba44fa39d1e4e8422bed3352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__phPatch.html#ga56ba1e16ffafba194b594eb752678835">pnxHal_Patch_Function_t</a> nxHal_Patch_TableEntry_t::wPatchReturnAddress</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>patch return address. </p>

</div>
</div>

</div>
</div>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga03b51e0a87daa85d7a6b938bbecdb569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NX_HAL_PATCH_NUM_OF_PATCHES&#160;&#160;&#160;48U</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of patches available in the Code Patch Module. </p>

</div>
</div>
<a class="anchor" id="gab296ffe5183cb1c9225a24ee2edab335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NX_HAL_PATCH_NULL_PTR&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wouldn't ((void *)0) be better ? </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga711c0a572054534b682a0d7124eb8925"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pnxHal_SVC_Handler_t)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype of fall-through SVC handler </p>

</div>
</div>
<a class="anchor" id="ga56ba1e16ffafba194b594eb752678835"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* pnxHal_Patch_Function_t)(void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype of a patch function. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga2ed3ea8e1f86480a3876241c6162a417"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__phPatch.html#ga2ed3ea8e1f86480a3876241c6162a417">nxHal_Patch_DynamicPatchGroup_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="gga2ed3ea8e1f86480a3876241c6162a417a1c5bcb4801752f95067edc84db48dd8e"></a>E_PAGEFLASH_DYNAMIC_PATCH_ZIGBEE</em>&nbsp;</td><td class="fielddoc">
<p>Zigbee Dynamic Patches group. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="gga2ed3ea8e1f86480a3876241c6162a417a25e6ed942179716d9279c9c4f9725d67"></a>E_PAGEFLASH_DYNAMIC_PATCH_BLE</em>&nbsp;</td><td class="fielddoc">
<p>Bluetooth Low Energy (BLE) Dynamic Patches group. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gaebe277a725c9d49517df2d4625b8147d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nxHal_Patch_Init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a> *&#160;</td>
          <td class="paramname"><em>pPatchTable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function initializes the patch module. It loads and applies all global patches. </p>

</div>
</div>
<a class="anchor" id="ga67ec032a6a497f3d885a7f592c2b0f22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nxHal_Patch_Apply </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bPatchNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bPatchTableOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>pOldPatchTableOffset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function updates the local lookup array with the provided parameters. <em>bPatchNumber</em> is the offset within the lookup array and <em>bPatchTableOffset</em> is written to this position. The code patch module registers are also updated properly.</p>
<dl class="section note"><dt>Note</dt><dd>Patch is automatically enabled after calling this function, so additional call to nxHal_Patch_EnableDisable is not necessary. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bPatchNumber</td><td>Number of the Patch to be configured. (0 &lt;= bPatchNumber &lt;= (<a class="el" href="group__phPatch.html#ga03b51e0a87daa85d7a6b938bbecdb569">NX_HAL_PATCH_NUM_OF_PATCHES</a> - 1) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bPatchTableOffset</td><td>Offset within the global patch table, i.e. position within the patch table where the information about this patch is stored. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">pOldPatchTableOffset</td><td>Old offset within the patch table. In case there was no patch set before, the value is set to #PH_HAL_PATCH_INVALID_PATCH_TABLE_OFFSET . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga77703a58c15e5a14f7158969d51ff8ba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nxHal_Patch_EnableDisable </td>
          <td>(</td>
          <td class="paramtype">nxHal_Patch_bool_t&#160;</td>
          <td class="paramname"><em>blEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bPatchNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function enables or disables the patch with the given <em>pPatchNumber</em>. If the given patch has not been configured before <a class="el" href="group__phPatch.html#ga67ec032a6a497f3d885a7f592c2b0f22" title="Apply a Patch. ">nxHal_Patch_Apply</a> needs to be called first.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="group__phPatch.html#ga77703a58c15e5a14f7158969d51ff8ba" title="Disable or Enable a Patch. ">nxHal_Patch_EnableDisable</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">blEnable</td><td>If set to TRUE the patch is enabled, otherwise disabled. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bPatchNumber</td><td>Number of the Patch to be enabled/disabled. (0 &lt;= bPatchNumber &lt;= (<a class="el" href="group__phPatch.html#ga03b51e0a87daa85d7a6b938bbecdb569">NX_HAL_PATCH_NUM_OF_PATCHES</a> - 1) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5676beb480f7f08664cd5041e2d99f2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t nxHal_Patch_GetGlobalPatchMarkerIndex </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function returns the index of the global patch marker. This marker reflects the last position of the global patches, i.e. patches loaded at startup. Since the number of patches is normally increasing during lifetime loading of dynamic patches needs to be done dynamically based on this index. So in fact the position of a dynamic patch is determined by the valud returned by this function + offset after global patch marker. </p>
<dl class="section return"><dt>Returns</dt><dd>Index of the global patch marker. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8bce87ce86d55e433218befc53770d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nxHal_Patch_ReadPatchEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a> *&#160;</td>
          <td class="paramname"><em>pBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__phPatch.html#structnxHal__Patch__TableEntry__t">nxHal_Patch_TableEntry_t</a> *&#160;</td>
          <td class="paramname"><em>pFlash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copy data area from the FLASH memory to the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>none. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">pBuffer</td><td>pointer on buffer to be copied </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pFlash</td><td>pointer on FLASH address to be read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga39fd6507a641ba3291ade6e82ec41664"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void nxHal_Patch_LoadDynamicPatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__phPatch.html#ga2ed3ea8e1f86480a3876241c6162a417">nxHal_Patch_DynamicPatchGroup_t</a>&#160;</td>
          <td class="paramname"><em>ePatchGroup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Function to load dynamic patches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePatchGroup</td><td>The group of dynamic patches to be loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.5-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul class="foot">
    <li class="footer">&copy; 2016 NXP Semiconductors. All rights reserved.
    </li>
  </ul>
</div>
</body>
</html>
